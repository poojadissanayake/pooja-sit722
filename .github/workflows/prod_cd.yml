name: CD - Production (All-in-One)

on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  deploy_prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ACR login
        run: az acr login --name ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}

      - name: Build & push backend images
        run: |
          docker build -t ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/product_service:latest ./backend/product_service
          docker push ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/product_service:latest

          docker build -t ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/order_service:latest ./backend/order_service
          docker push ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/order_service:latest

          docker build -t ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/customer_service:latest ./backend/customer_service
          docker push ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/customer_service:latest

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ vars.PROD_AKS_RESOURCE_GROUP }}" \
            --name "${{ vars.PROD_AKS_CLUSTER_NAME }}" \
            --overwrite-existing
          kubectl cluster-info

      # backend: config + secrets + DBs
      - name: Apply backend infra manifests
        run: |
          cd k8s-prod
          kubectl apply -f configmaps.yaml
          kubectl apply -f secrets.yaml
          kubectl apply -f product-db.yaml
          kubectl apply -f order-db.yaml
          kubectl apply -f customer-db.yaml

      # Inject Storage creds into ecommerce-secret-w10t2 for product-service
      - name: Ensure storage keys are in ecommerce-secret-w10t2
        shell: bash
        run: |
          set -e
          NS=default
          SA_NAME='${{ secrets.PROD_STORAGE_ACCOUNT_NAME }}'
          if [ -z "$SA_NAME" ]; then
            echo "Missing PROD_STORAGE_ACCOUNT_NAME secret"; exit 1
          fi

          # Prefer a pre-supplied key if you added PROD_STORAGE_ACCOUNT_KEY
          SA_KEY='${{ secrets.PROD_STORAGE_ACCOUNT_KEY }}'

          if [ -z "$SA_KEY" ]; then
            echo "No PROD_STORAGE_ACCOUNT_KEY provided; discovering RG and fetching a key..."
            SA_RG=$(az storage account show -n "$SA_NAME" --query resourceGroup -o tsv)
            if [ -z "$SA_RG" ]; then
              echo "Could not discover RG for storage account $SA_NAME"; exit 1
            fi
            SA_KEY=$(az storage account keys list -g "$SA_RG" -n "$SA_NAME" --query "[0].value" -o tsv)
            if [ -z "$SA_KEY" ]; then
              echo "Failed to retrieve storage key for $SA_NAME"; exit 1
            fi
          fi

          # Merge keys into the core secret (created by secrets.yaml)
          kubectl -n "$NS" patch secret ecommerce-secret-w10t2 \
            --type merge \
            -p "{\"stringData\":{
              \"AZURE_STORAGE_ACCOUNT_NAME\":\"$SA_NAME\",
              \"AZURE_STORAGE_ACCOUNT_KEY\":\"$SA_KEY\"
            }}"

      # backend services (Deployments + Services)
      - name: Deploy backend services
        run: |
          cd k8s-prod
          kubectl apply -f product-service.yaml
          kubectl apply -f order-service.yaml
          kubectl apply -f customer-service.yaml

      - name: Wait for backend LoadBalancer IPs
        id: wait_ips
        shell: bash
        run: |
          set -e
          echo "Waiting for Product/Order/Customer external IPs..."
          PRODUCT_IP=""
          ORDER_IP=""
          CUSTOMER_IP=""

          for i in $(seq 1 60); do
            PRODUCT_IP=$(kubectl get svc product-service-w10t2   -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            ORDER_IP=$(kubectl   get svc order-service-w10t2     -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            CUSTOMER_IP=$(kubectl get svc customer-service-w10t2 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            echo "Attempt $i: P=$PRODUCT_IP O=$ORDER_IP C=$CUSTOMER_IP"
            if [[ -n "$PRODUCT_IP" && -n "$ORDER_IP" && -n "$CUSTOMER_IP" ]]; then
              break
            fi
            sleep 5
          done

          if [[ -z "$PRODUCT_IP" || -z "$ORDER_IP" || -z "$CUSTOMER_IP" ]]; then
            echo "Timeout waiting for LB IPs"; exit 1
          fi

          echo "PRODUCT_IP=http://$PRODUCT_IP:8000"   >> $GITHUB_ENV
          echo "ORDER_IP=http://$ORDER_IP:8001"       >> $GITHUB_ENV
          echo "CUSTOMER_IP=http://$CUSTOMER_IP:8002" >> $GITHUB_ENV

      - name: Acceptance tests (health checks)
        shell: bash
        run: |
          set -e
          echo "Product:   $PRODUCT_IP"
          echo "Order:     $ORDER_IP"
          echo "Customer:  $CUSTOMER_IP"
          curl -f "$PRODUCT_IP/health"
          curl -f "$ORDER_IP/health"
          curl -f "$CUSTOMER_IP/health"

      # frontend: inject URLs, build/push, deploy
      - name: Inject backend URLs into frontend/main.js
        run: |
          sed -i "s|_PRODUCT_API_URL_|$PRODUCT_IP|g"   frontend/main.js
          sed -i "s|_ORDER_API_URL_|$ORDER_IP|g"       frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|$CUSTOMER_IP|g" frontend/main.js
          echo "Preview:"
          head -n 20 frontend/main.js

      - name: Build & push frontend image
        run: |
          docker build -t ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/frontend:latest ./frontend
          docker push    ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io/frontend:latest

      - name: Deploy frontend
        run: kubectl apply -f k8s-prod/frontend.yaml

      - name: Done
        run: echo "Production deployment completed successfully!"
