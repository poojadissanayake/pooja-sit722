name: CD - Staging (Create, Deploy, Test, Destroy All)

on:
  push:
    branches: [ testing ]
    paths:
      - '.terraform/**'
      - 'k8s/**'
      - '.github/workflows/staging_cd.yml'
  workflow_dispatch:

env:
  KUBECONFIG: ${{ runner.temp }}/kubeconfig

jobs:
  # Job 1: Provision full staging infra + deploy backends and basic checks
  provision_and_deploy:
    runs-on: ubuntu-latest
    environment: Staging
    outputs:
      rg:           ${{ steps.tf_out.outputs.rg }}
      aks:          ${{ steps.tf_out.outputs.aks }}
      acr:          ${{ steps.tf_out.outputs.acr }}
      sa_name:      ${{ steps.tf_out.outputs.sa_name }}
      sa_key:       ${{ steps.tf_out.outputs.sa_key }}
      img_container: ${{ steps.tf_out.outputs.img_container }}
      product_ip:   ${{ steps.capture.outputs.product_ip }}
      order_ip:     ${{ steps.capture.outputs.order_ip }}
      customer_ip:  ${{ steps.capture.outputs.customer_ip }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: .terraform
        run: terraform init

      - name: Terraform Apply (create RG, ACR Basic+admin, AKS, Storage+container)
        id: tf_apply
        working-directory: .terraform
        env:
          TF_VAR_acr_name: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
        run: terraform apply -auto-approve

      - name: Read Terraform Outputs
        id: tf_out
        working-directory: .terraform
        run: |
          echo "rg=$(terraform output -raw staging_rg_name)" >> $GITHUB_OUTPUT
          echo "aks=$(terraform output -raw staging_aks_name)" >> $GITHUB_OUTPUT
          echo "acr=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "sa_name=$(terraform output -raw storage_account_name)" >> $GITHUB_OUTPUT
          echo "sa_key=$(terraform output -raw storage_account_key)"  >> $GITHUB_OUTPUT
          echo "img_container=$(terraform output -raw product_images_container)" >> $GITHUB_OUTPUT

      - name: Get AKS credentials (staging)
        run: |
          az aks get-credentials \
            -g "${{ steps.tf_out.outputs.rg }}" \
            -n "${{ steps.tf_out.outputs.aks }}" \
            --overwrite-existing \
            --file "$KUBECONFIG"
          kubectl --kubeconfig "$KUBECONFIG" cluster-info

      - name: Attach ACR to AKS (idempotent)
        run: az aks update -g "${{ steps.tf_out.outputs.rg }}" -n "${{ steps.tf_out.outputs.aks }}" --attach-acr "${{ steps.tf_out.outputs.acr }}"

      # Create/merge the secret with Storage creds so product-service can use Azure Blob
      - name: Create/Update ecommerce-secret-w10t2 with storage creds
        shell: bash
        run: |
          NS=default
          kubectl --kubeconfig "$KUBECONFIG" -n "$NS" create secret generic ecommerce-secret-w10t2 \
            --from-literal=AZURE_STORAGE_ACCOUNT_NAME='${{ steps.tf_out.outputs.sa_name }}' \
            --from-literal=AZURE_STORAGE_ACCOUNT_KEY='${{ steps.tf_out.outputs.sa_key }}' \
            --dry-run=client -o yaml | kubectl --kubeconfig "$KUBECONFIG" -n "$NS" apply -f -

      - name: Deploy backend infra (ConfigMaps/Secrets/DBs)
        run: |
          cd k8s/
          kubectl --kubeconfig "$KUBECONFIG" apply -f configmaps.yaml
          kubectl --kubeconfig "$KUBECONFIG" apply -f secrets.yaml
          kubectl --kubeconfig "$KUBECONFIG" apply -f product-db.yaml
          kubectl --kubeconfig "$KUBECONFIG" apply -f order-db.yaml
          kubectl --kubeconfig "$KUBECONFIG" apply -f customer-db.yaml

      - name: Deploy backend services (Product/Order/Customer)
        run: |
          cd k8s/
          kubectl --kubeconfig "$KUBECONFIG" apply -f product-service.yaml
          kubectl --kubeconfig "$KUBECONFIG" apply -f order-service.yaml
          kubectl --kubeconfig "$KUBECONFIG" apply -f customer-service.yaml

      - name: Wait for LoadBalancer IPs
        id: capture
        shell: bash
        run: |
          for i in $(seq 1 60); do
            P=$(kubectl --kubeconfig "$KUBECONFIG" get svc product-service-w08e1   -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            O=$(kubectl --kubeconfig "$KUBECONFIG" get svc order-service-w08e1     -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            C=$(kubectl --kubeconfig "$KUBECONFIG" get svc customer-service-w08e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [[ -n "$P" && -n "$O" && -n "$C" ]]; then
              echo "product_ip=$P"  >> $GITHUB_OUTPUT
              echo "order_ip=$O"    >> $GITHUB_OUTPUT
              echo "customer_ip=$C" >> $GITHUB_OUTPUT
              echo "IPs: $P, $O, $C"
              exit 0
            fi
            sleep 5
          done
          echo "Timed out waiting for LoadBalancer IPs"; exit 1

      - name: Quick acceptance checks
        run: |
          curl --fail "http://${{ steps.capture.outputs.product_ip }}:8000/health"
          curl --fail "http://${{ steps.capture.outputs.order_ip }}:8001/health"
          curl --fail "http://${{ steps.capture.outputs.customer_ip }}:8002/health"

  # Job 2: (after manual approval window) Deploy frontend and DESTROY EVERYTHING (full terraform destroy)
  finalize_and_destroy:
    runs-on: ubuntu-latest
    needs: provision_and_deploy
    environment: Staging
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # deploy the frontend for end-to-end testing before destroy
      - name: Deploy Frontend (reusable)
        uses: ./.github/workflows/frontend_cd.yml
        with:
          product_api_ip:   "http://${{ needs.provision_and_deploy.outputs.product_ip }}:8000"
          order_api_ip:     "http://${{ needs.provision_and_deploy.outputs.order_ip }}:8001"
          customer_api_ip:  "http://${{ needs.provision_and_deploy.outputs.customer_ip }}:8002"
          aks_cluster_name: ${{ needs.provision_and_deploy.outputs.aks }}
          aks_resource_group: ${{ needs.provision_and_deploy.outputs.rg }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Destroy (DESTROY EVERYTHING)
        working-directory: .terraform
        env:
          TF_VAR_acr_name: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
        run: |
          # This removes ALL resources created
          terraform destroy -auto-approve